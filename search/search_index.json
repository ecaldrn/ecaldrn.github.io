{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#hey-welcome-to-my-portfolio-where-youll-find-my-resume-notes-about-my-learning-journey-as-well-as-my-projects-related-to-software-engineering","title":"Hey ! Welcome to my portfolio, where you'll find my resume, notes about my learning journey as well as my projects related to Software Engineering.","text":"<p> I'm a software engineer that is currently working in R&amp;D in the automotive industry in Japan. I am interested in automotive software (ADAS and Autonomous driving), robotics, and computer vision. Passionate about sharing and empowering students during my university days, I volunteered for IEEE student chapter of my university to organize tech related events.  Hobbies:\ud83c\udfc0,\ud83c\udfd0,\ud83c\udfa7.  </p> <p>PDF Resume </p>"},{"location":"#skills","title":"Skills","text":"<p>Software development </p> <ul> <li> Modern C++ (Mostly focused on C++20). </li> <li> \ud83d\udc0d Python (Numpy, Pandas, Matplotlib, standard library)</li> <li> \ud83e\udd16 Machine Learning (CNNs, Tensorflow &amp; PyTorch, Scikit-learn) </li> <li> \ud83e\uddd1\ud83c\udffb\u200d\ud83d\udcbb Git \u2022 SQL \u2022 \ud83d\udc27Linux CLI &amp; Bash scripting \u2022 HTML and CSS \u2022 Markdown</li> </ul> <p>\ud83c\udfce\ufe0f Automotive development </p> <ul> <li> ADAS systems</li> <li> Autonomous Emergency Brake (AEB)</li> <li> Brake Systems </li> <li> Matlab &amp; Simulink </li> <li> CAN \u2022 Ethernet  </li> </ul> <p>Other: Spanish (mother tongue), English native (TOEFL 560 | TOEIC 960), Japanese (business proficiency), French (B1).</p>"},{"location":"#experience","title":"Experience","text":""},{"location":"#research-and-development-engineer-mazda-motor-corporation-oct-2023-present","title":"Research and Development Engineer @ Mazda Motor Corporation  \u2022 Oct 2023 - Present","text":"<ul> <li>Validated the Autonomous Emergency Braking System (AEB) model through the design, implementation and execution of the testing scenarios required to pass test protocols such as NCAP.</li> <li>Integrated model and evaluation pipeline for pedal misapplication and acceleration suppression features in Smart Brake Support (SBS) ADAS system using Matlab, Simulink, and CarMaker.</li> </ul>"},{"location":"#education","title":"Education","text":""},{"location":"#me-in-electrical-systems-and-control-engineering-hiroshima-university-oct-2021-sep-2023","title":"M.E. in Electrical, Systems and Control Engineering \u2022 Hiroshima University \u2022 Oct 2021 - Sep 2023","text":"<p>Global Jinzai Program grant receiver. Member of the Biological Systems Engineering Laboratory in the Human Modelling and Augmentation Group. Majored in soft robotics control algorithms for rehabilitation devices.</p> <ul> <li>3 papers published during the two years as well as speaker in International Conferences.</li> <li>1 book chapter authored on VR systems for rehabilitation.</li> <li>\ud83e\udd48Best International presentation finalist in the 41st annual conference Robotics Society of Japan 2023.</li> </ul>"},{"location":"#leading-digital-transformation-program-mit-professional-education-remote-may-2020-jun-2020","title":"Leading Digital Transformation program \u2022 MIT Professional Education, Remote \u2022 May 2020 - Jun 2020","text":"<p>Leading Digital Transformation program. Five weeks online program focused on developing the Digital Transformation and Leadership skills required to make a successful transition from the traditional approach using both theory as well as real case-study scenarios. Full scholarship provided by Santander Bank.</p>"},{"location":"#be-in-mechatronics-engineering-guanajuato-university-mexico-oct-2015-dec-2020","title":"B.E. in Mechatronics engineering \u2022 Guanajuato University, Mexico \u2022 Oct 2015 - Dec 2020","text":"<p>Bachelor of Engineering in Mechatronics engineering. Worked with Keras to train Convolutional Neural Networks and analyze skull x-ray medical images. Relevant coursework: Computer vision, robotics, artificial intelligence. </p> <ul> <li>\ud83e\udd48 Undergraduate thesis awarded with honorific mention at the 20th National Mechatronics Conference (December 10th, 2021).</li> <li>IEEE student branch: chairman for three years, organized workshops, conferences, contests. Guanajuato section representative at the R9 Latin American meeting 2018.</li> <li>Research poster presented at the 2nd International Meeting of Artificial Intelligence and its Applications. Paper presented in IEEE International conference. </li> </ul>"},{"location":"notes/","title":"Notes about the topics I'm passionate about","text":"<p>I'll use this files to ...</p>"},{"location":"notes/#why-making-notes","title":"Why making notes","text":""},{"location":"Notes/automotive/canbus/","title":"CAN BUS","text":""},{"location":"Notes/cpp/cpp/","title":"C++ general notes","text":""},{"location":"Notes/cs/linux/","title":"Linux general notes","text":"<p> Linux is a  </p>"},{"location":"Notes/cs/linux/#skills","title":"Skills","text":""},{"location":"Notes/dsa/algorithms/","title":"Algorithms","text":"<p>A problem can be seen as a binary relationship between input(s) and output(s). In order to solve complex, computational problems, capable to take an arbitrary number of inputs, we need to learn about algorithm design. </p>"},{"location":"Notes/dsa/algorithms/#what-is-an-algorithm","title":"What is an algorithm ?","text":"<p>An algorithm is a well defined procedure to solve accomplish a desired specific task (solving a problem, sorting data, etc.). To accomplish the task in hand, the algorithm will take as input one value or a set or values, and will return one value or a set of values as output. This processing is done in a finite amount of time. </p> <p>We can also think about an Algorithm as the required computational steps that will transform the problem's input into output, this is a function f that maps input I to output O. </p>"},{"location":"Notes/dsa/algorithms/#when-an-algorithm-is-correct","title":"When an algorithm is correct ?","text":"<p>An algorithm is correct if, for every problem instance provided as input, it halts-finishes its computing in finite time- and outputs the correct solution to the problem instance <sup>1</sup>.</p>"},{"location":"Notes/dsa/algorithms/#why-it-is-necessary-to-learn-algorithms","title":"Why it is necessary to learn algorithms ?","text":"<p>Because by learning about algorithm design, we can identify which procedure is the optimal for our task/data at hand, evaluate our solution, and prove that the algorithm is both correct and efficient.</p> <p>Also, if the problem gets more complex, or the quantity of input data increases, we can make the necessary changes so the performance is not impacted. </p> <p>Finally, the knowledge of algorithms gives us the tools and objective expressions necessary to communicate our solution to others regardless the programming language or the hardware in which the solution will be implemented. </p> <ol> <li> <p>Cormen, T.H. et al. (2022) Introduction to algorithms. Cambridge, MA: The MIT Press.\u00a0\u21a9</p> </li> <li> <p>Goodrich, M.T., Tamassia, R. and Goldwasser, M.H. (2013) Data Structures and algorithms in Python. Hoboken, NJ: Wiley.\u00a0\u21a9</p> </li> <li> <p>Skiena, S.S. (2020) The Algorithm Design Manual. 3rd edn. Springer.\u00a0\u21a9</p> </li> <li> <p>Introduction to algorithms: Electrical Engineering and computer science MIT OpenCourseWare. Available at: https://ocw.mit.edu/courses/6-006-introduction-to-algorithms-spring-2020/ (Accessed: 29 September 2024).\u00a0\u21a9</p> </li> </ol>"},{"location":"Notes/dsa/binary_search/","title":"Binary Search","text":"<p>By using the divide and conquer approach, this algorithm allows us to look for elements in a sorted array in an efficient manner, as it reduces the search space by 2 at every iteration.</p> <p>Input </p> <ol> <li>nums = array of ints, sorted in ascending order. All the elements in nums are unique.</li> <li>target = int</li> </ol> <p>Output: If target exists in nums, return its index. Otherwise, return -1</p> <p>Time complexity: O(Log(n))</p> <p>Space complexity: O(1)</p> C++Python Binary Search<pre><code>#include &lt;vector&gt;\n\nint search(vector&lt;int&gt;&amp; nums, int target) {\n    int left = 0;\n    int right = nums.size() - 1;\n    int mid;\n\n    while (left &lt;= right){\n\n        mid = (left + right)/2;\n\n        if (nums[mid] == target)\n            return mid;\n        else if (target &gt; nums[mid])\n            left = mid + 1;\n        else\n            right = mid - 1;\n    }\n    return -1;\n}\n</code></pre> Binary Search<pre><code>def search(nums: list[int], target: int) -&gt; int:\n    left = 0 \n    right = len(nums) - 1\n\n    while left &lt;= right:\n        mid = (left + right)//2\n\n        if nums[mid] == target:\n            return mid\n        elif target &gt; nums[mid]:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n</code></pre>"},{"location":"Notes/dsa/breadth_first_search/","title":"Breadth-First Search","text":"<p>This approach of traversing a graph will give you the shortest path to a given node. </p>"},{"location":"Notes/dsa/breadth_first_search/#main-applications","title":"Main applications","text":"<ul> <li>Flight reservation systems</li> <li>GPS</li> <li>Many social networks uses BFS to map your friend/connection suggestions. </li> <li>Web crawlers</li> <li>Flood fill (The bucket-fill function in Paint program). </li> </ul> <p>Time complexity: O(V + E) where V is the number of vertices of the graph, while E is the number of edges.</p> <p>Space complexity: </p> C++Python BFS in C++<pre><code>#include &lt;vector&gt;\n\nint dfs(vector&lt;int&gt;&amp; nums, int target) {\n\n    return -1;\n}\n</code></pre> BFS iterative approach<pre><code># We will use a queue to keep track of nodes to visit\nmarked = [False] * graph.size()\n\ndef bfs_iter(graph, v):\n    queue = [v]\n    while len(queue) &gt; 0: #As long as we have nodes to visit\n        v = stack.pop()\n\n        if not marked[v]:\n            visit(v)\n            marked[v] = True\n\n            for w in graph.neighbors(v):\n                if not marked[w]:\n                    queue.enqueue(w)\n</code></pre> <p>Useful resource https://youtu.be/xlVX7dXLS64</p>"},{"location":"Notes/dsa/depth_first_search/","title":"Depth-First Search","text":"<p>What a graph traversal means ? From a arbitrary start node, being able to get to every other vertex in the graph. An algorithm to visit every vertex of a graph. Many of the graph traversal algorithms are different by the order in which they visit vertices. </p> <p>As we will continue on a particular path until either it finds its goal or reaches a dead end, it is considered an agressive algorithm. DFS is better in situations in which the goal is to discover a path to a given destination as soon as possible, even though this path could not always be the shortest one.</p>"},{"location":"Notes/dsa/depth_first_search/#main-applications","title":"Main applications","text":"<ul> <li>Criteria-based optimizations: It can be cost, speed, safety, fuel,etc. depending on your application. </li> <li>Pathfinding</li> <li>Maze generation</li> <li>Scheduling algorithms</li> <li>Determining the order of compilation tasks for software builds.</li> <li>Data serialization</li> <li>Resolving symbol dependencies.</li> <li>Simulation of some games.</li> </ul> <p>We have a recursive and iterative approaches for DFS, and even though they both have the same runtime, most of the times the recursive approach is more used given that is cleaner and easier to read. We also have preorder (we add the node as soon as we checked that it was not in the visited list) and posorder (we add the node until it is a dead-end = we visited all the neighbor nodes) traversal arrangements. </p> <p>Time complexity: O(V + E) where V is the number of vertices of the graph, while E is the number of edges.</p> <p>Space complexity: </p> C++Python Depth-First Search in C++<pre><code>#include &lt;vector&gt;\n\nint dfs(vector&lt;int&gt;&amp; nums, int target) {\n\n    return -1;\n}\n</code></pre> <p>DFS recursive approach<pre><code># Graphs are represented using adjacency lists\nmarked = [False] * graph.size() # List used to mark visited nodes\n\ndef dfs(graph, v):\n    visit(v) \n    marked[v] = True\n\n    for w in graph.neighbors(v):\n        if not marked[w]:\n            dfs(graph, w)\n</code></pre> DFS iterative approach<pre><code># We will use a stack to keep track of nodes to visit\nmarked = [False] * graph.size()\n\ndef dfs_iter(graph, v):\n    stack = [v]\n    while len(stack) &gt; 0: #As long as we have nodes to visit\n        v = stack.pop()\n\n        if not marked[v]:\n            visit(v)\n            marked[v] = True\n\n            for w in graph.neighbors(v):\n                if not marked[w]:\n                    stack.push(w)\n</code></pre></p> <p>Useful resource https://youtu.be/PMMc4VsIacU</p>"},{"location":"Notes/dsa/ds/","title":"Data structures","text":"<p>Depending on the task in hand, the solution can be simplified (and optimized) by choosing the right layout for the existing data. Thats where data structures appear, by giving us specific ways to store our data so we can process and access data in an efficient way. Then we can define a Data Structure as a \"systematic way of organizing and processing information\" <sup>1</sup>.</p> <ol> <li> <p>Goodrich, M.T., Tamassia, R. and Goldwasser, M.H. (2013) Data Structures and algorithms in Python. Hoboken, NJ: Wiley.\u00a0\u21a9</p> </li> </ol>"},{"location":"Notes/dsa/linked_lists/","title":"Linked Lists","text":"<p>A linked list is a collection of independent memory locations called nodes. Nodes are connected through links in a linear order. The links are usually implemented as pointers. Linked lists are sometimes an alternative to overcome some of the limitations of the typical array such as fixed length and unnecessary storage use. </p> <p>To represent the linked list, we use a pointer to the first node. This first node is called the head of the linked list, while the last node is called the tail. When the linked list is empty, the value of the head is NULL (or None in Python).</p> <p>While insertion at the beginning and end of the list has a O(1) complexity, accessing to elements can have a O(n) in the worst case scenario because it is not possible to locate the elements in the nodes by index. Also, deletion at every position can take O(n) in the worst case as it is necessary to traverse the list in order to find the element to delete. It is possible to remove the head of the list in O(1).</p>"},{"location":"Notes/dsa/linked_lists/#member-functions-and-attributes","title":"Member functions and attributes","text":"<ul> <li> <p>linked_list.push(element): Add an element at the head of the linked list (if the linked list is implemented using a stack, it will add an element to the top of the stack). </p> </li> <li> <p>linked_list.delete(node): </p> </li> <li> <p>myNode.value(): A reference to the element stored in the node</p> </li> <li> <p>myNode.next(): The reference to the next node in the list. myNode.next() will be NULL if the list is empty or if the myNode is the last node in the singly linked list. </p> </li> </ul>"},{"location":"Notes/dsa/linked_lists/#applications","title":"Applications","text":"<p>Linked lists are used to represent filesystems (hierarchical structure of the directories), to implement another data structures such as stacks or queues, graph implementation which uses linked lists to store adjacent vertices.</p>"},{"location":"Notes/dsa/linked_lists/#code-implementation","title":"Code Implementation","text":"<p>For the main implementation, we will declare a Node, which will contain certain type of data, as well as a pointer (or reference) to the next node. </p>"},{"location":"Notes/dsa/linked_lists/#python-implementation","title":"Python implementation","text":"<p>From the LeetCode linked list implementation to define a linked list [1, 2, 4], you write \"l1 = ListNode(1,ListNode(2, ListNode(3, None)))\". Hence, to get the first value (the head) of l1, we do \"l1.val\"; to get second value, we do \"l1.next.val\"; and to get the third value, we do \"l1.next.next.val\"</p> Python <p>Singly Linked List<pre><code># Code from this video: https://youtu.be/dqLHTK7RuIo\nclass Node:\n    def __init__(self, val, next=None):\n        self.val = val\n        self.next = next\n\n    def __str__(self):\n        return str(self.val)\n\n#Traverse the singly linked list\n#curr = Head\n#while curr: #This implies while curr != None\n#    print(curr)\n#    curr = curr.next\n\n#Display the linked list\ndef display(Head):\n    curr = Head\n    elements = []\n\n    while curr:\n        elements.append(curr.val)\n        curr = curr.next\n\n    print(\" -&gt; \".join(elements))\n\n# Search for a given element in the list\ndef search(head, target):\n    curr = head\n\n    while curr:\n        if target == curr.val:\n            return True\n        curr = curr.next\n\n    return False\n\n# How to use the class\n# Create the List defined by Head -&gt; A -&gt; B -&gt; C\n# Create the isolated nodes, then make the connections\nHead = Node(1)\nA = Node(3)\nB = Node (4)\n\nHead.next = A\nA.next = B\nB.next = C\n\ndisplay(Head) # Will print 1 -&gt; 3 -&gt; 4\nsearch(Head, 2) # Will return False\n</code></pre> Doubly linked lists<pre><code>class DoublyNode:\n    def __init__(self, val, next=None, prev=None):\n        self.val = val\n        self.next = None\n        self.prev = None\n\n    def __str__(self):\n        return str(self.val)\n\n#Display the doubly linked list\ndef display(Head):\n    curr = Head\n    elements = []\n\n    while curr:\n        elements.append(curr.val)\n        curr = curr.next\n\n    print(\" &lt;-&gt; \".join(elements))\n\ndef insert_at_beginning(head, tail, val):\n    new_node = DoublyNode(val, next=head)\n    head.prev = new_node\n    return new_node, tail\n\ndef insert_at_end(head, tail, val):\n    new_node = DoublyNode(val, next=tail)\n    tail.prev = new_node\n    return head, new_node\n\n# Calling the functions\nhead, tail = insert_at_beginning(head, tail, 3)\ndisplay(head)       \n</code></pre></p>"},{"location":"Notes/dsa/linked_lists/#c-implementation","title":"C++ implementation","text":"C++ Linked list using a structure and pointers (Classic)<pre><code>//Used code from: \n// https://www.linkedin.com/learning/nail-your-c-plus-plus-interview\n#include &lt;iostream&gt;\n#include &lt;cstdlib&gt;\nusing namespace std;\n\nstruct Node{\nint data;\nNode *next;\n};\n\nvoid insert(struct Node** head, int newData);\nvoid printList(struct Node *head);\nvoid deleteNode(struct Node** head, int position);\n\nint main(){\nNode* head = NULL;\n\ninsert(&amp;head, 9);\ninsert(&amp;head, 1);\ninsert(&amp;head, 3);\ninsert(&amp;head, 8);\n\ncout &lt;&lt; \"Created \" &lt;&lt; endl;\nprintList(head);\ndeleteNode(&amp;head, 3);\ncout &lt;&lt; \"\\n After deletion of position 3 \" &lt;&lt; endl;\nprintList(head);\nreturn 0;\n}\n\nvoid insert(struct Node** head, int newData){\nstruct Node* newNode = (struct Node*) malloc(sizeof(struct Node));\n\nnewNode-&gt;data =  newData;\nnewNode-&gt;next = *head;\n\n*head = newNode;\n}\n\nvoid deleteNode(struct Node** head, int position){\nif (*head == NULL) //if the list is empty, simply return\n    return;\n\nstruct Node* temp = *head; //create new pointer to head\n\n//if they want to delete head, move head to next item, delete and return\nif (position == 0){\n    *head = temp-&gt;next;\n    free(temp);\n    return;\n}\n\n//cycle through list until end or node b4 position\nfor (int i=0; temp!=NULL &amp;&amp; i &lt; position-1; i++){\n    temp = temp-&gt;next;\n}\n\nif (temp == NULL || temp-&gt;next == NULL) ////if end of list, return\n    return;\n\n//create new pointer to point to positions pointer\nstruct Node *next = temp-&gt;next-&gt;next;\n//delete position\nfree(temp-&gt;next);\n//unlink node\ntemp-&gt;next = next;\n}\n\nvoid printList(struct Node *head){\nwhile (head != NULL){\n    cout &lt;&lt; head-&gt;data;\n    head = head-&gt;next;\n}\n}\n</code></pre> <p>In addition to the \"from zero\" implementation, we can also leverage the defined container forward_list, defined in STL. </p> C++ Singly linked list using STL forward_list container<pre><code>#include &lt;iostream&gt;\n#include &lt;forward_list&gt;\nusing namespace std;\n\nstruct node(vector&lt;int&gt;&amp; nums, int target) {\n}\n</code></pre> <p>Finally, we have the list container, that is defines a doubly-linked list and is included in the STL C++ library. </p> C++ Doubly Linked list using a STL list container<pre><code>#include &lt;iostream&gt;\n#include &lt;list&gt;\nusing namespace std;\n\nstruct node(vector&lt;int&gt;&amp; nums, int target) {\n}\n</code></pre> <ol> <li> <p>Cormen, T.H. et al. (2022) Introduction to algorithms. Cambridge, MA: The MIT Press.\u00a0\u21a9</p> </li> <li> <p>Goodrich, M.T., Tamassia, R. and Goldwasser, M.H. (2013) Data Structures and algorithms in Python. Hoboken, NJ: Wiley.\u00a0\u21a9</p> </li> <li> <p>Skiena, S.S. (2020) The Algorithm Design Manual. 3rd edn. Springer.\u00a0\u21a9</p> </li> <li> <p>Introduction to algorithms: Electrical Engineering and computer science MIT OpenCourseWare. Available at: https://ocw.mit.edu/courses/6-006-introduction-to-algorithms-spring-2020/ (Accessed: 29 September 2024).\u00a0\u21a9</p> </li> <li> <p>Data Structures &amp; Algorithms - Linked Lists - Singly Linked Lists. Available at: https://youtu.be/gpvtfbwgUxM?list=PLaBPUIXZ8s4D2onKZ2wj7dUCglYfA5wBd\u00a0\u21a9</p> </li> </ol>"},{"location":"Notes/dsa/queue/","title":"Queue","text":"<p>A queue is a FIFO (First In, First Out) linear structure. You can think this data structure as a queue in the supermarket cashier, in which the first person that lines up, is the first person to be served. In a queue, the elements are inserted from the \"back\" (at the end of the structure) and are removed from the front (the start of the structure).</p>"},{"location":"Notes/dsa/queue/#member-functions-and-atributes","title":"Member functions and atributes","text":"<ul> <li> <p>queue.enqueue(element): Add the element to the back of the Queue. This method has a O(1) complexity.</p> </li> <li> <p>queue.dequeue(): Retrieves, removes from queue, and returns the element at the front of the queue. This method has a O(1) complexity.</p> </li> <li> <p>queue.first(): Returns a reference to the element at the front of the Queue (first element, 0 index). This method has a O(1) complexity.</p> </li> <li> <p>queue.is_empty(): Returns True if queue is there are no elements in queue. </p> </li> <li> <p>len(queue): Returns the number of elements of the queue. </p> </li> </ul>"},{"location":"Notes/dsa/queue/#applications","title":"Applications","text":"<p>Queues are applied to web server requests management, process management in operative systems-job scheduling, as a base of very important algorithms such as Breadth-First search (BFS), song queue in music players and apps, printer queues, etc.  </p>"},{"location":"Notes/dsa/queue/#code-implementation","title":"Code Implementation","text":"<p>For the main implementation, we decided to use deque over List because list would be slow in the inserts or pops from the beginning of the list, as we would have to shift all the elements one position (O(n)).  Also, we are considering 0th position (left) as the head of the queue and (n-1) position (right) as the tail of our queue. </p>"},{"location":"Notes/dsa/queue/#python-implementation","title":"Python implementation","text":"Python Queue implementation using Deque<pre><code>    from collections import deque\n\n    class Queue:\n        def __init__(self):\n            self.items = deque()\n\n        def is_empty(self):\n            return not self.items #Same as len(self.items) == 0\n\n        def enqueue(self, item):\n            self.items.append(item)\n\n        def dequeue(self):\n            return self.items.popleft()\n\n        def peek(self):\n            return self.items[0] #Item of the head of the queue\n\n        def size(self):\n            return len(self.items)\n\n        def __str__(self):\n            return str(self.items)\n</code></pre>"},{"location":"Notes/dsa/queue/#c-implementation","title":"C++ implementation","text":"<p>In addition to the \"from zero\" implementation, we can also leverage the defined container , defined in STL. </p> <ol> <li> <p>Cormen, T.H. et al. (2022) Introduction to algorithms. Cambridge, MA: The MIT Press.\u00a0\u21a9</p> </li> <li> <p>Goodrich, M.T., Tamassia, R. and Goldwasser, M.H. (2013) Data Structures and algorithms in Python. Hoboken, NJ: Wiley.\u00a0\u21a9</p> </li> <li> <p>Skiena, S.S. (2020) The Algorithm Design Manual. 3rd edn. Springer.\u00a0\u21a9</p> </li> <li> <p>Introduction to algorithms: Electrical Engineering and computer science MIT OpenCourseWare. Available at: https://ocw.mit.edu/courses/6-006-introduction-to-algorithms-spring-2020/ (Accessed: 29 September 2024).\u00a0\u21a9</p> </li> <li> <p>Data Structures &amp; Algorithms - Linked Lists - Singly Linked Lists. Available at: https://youtu.be/gpvtfbwgUxM?list=PLaBPUIXZ8s4D2onKZ2wj7dUCglYfA5wBd\u00a0\u21a9</p> </li> </ol>"},{"location":"Notes/dsa/reverse_linked_list/","title":"Reverse a linked list","text":"<p>Input </p> <ol> <li>.</li> <li>.</li> </ol> <p>Output: 1</p> <p>Time complexity: O()</p> <p>Space complexity: O</p> C++Python Reverse a Linked List in C++<pre><code>#include &lt;vector&gt;\n\nint search(vector&lt;int&gt;&amp; nums, int target) {\n}\n</code></pre> Reverse a Linked List in Python<pre><code># Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n# Input: head of a linked list\n# Output: Return the reversed list.\n# Time O(n)\n# Space O(1)\n\nclass Solution:\n    def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:\n        current = head\n        prev = None\n\n        while (current):\n            tmp = current.next # Keeps the list from current.next till the end\n            current.next = prev # Change the orientation of the nodes links (reverses the connections)\n            prev = current # Moves in to the next node\n            current = tmp\n\n        return prev\n</code></pre>"},{"location":"Notes/dsa/stack/","title":"Stack","text":"<p>A stack is a LIFO (Last In, First Out) linear structure. In a stack, insertions and deletions made only in one end, called the top of the stack. You can think the stack as a stack of plates in a restaurant, in which you cannot get the plate in the bottom without removing the ones that are on top. Stacks can be used as base to create another data structures. </p>"},{"location":"Notes/dsa/stack/#member-functions-and-atributes","title":"Member functions and atributes","text":"<ul> <li> <p>Stack.push(element): This will add element to the top of the stack. It has a running time of O(1).</p> </li> <li> <p>Stack.pop(): Retrieves, removes from stack, and returns the element in the top of the stack (last element added). It has a running time of O(1).</p> </li> <li> <p>Stack.top(): References to the element in the top of the stack without removing it. Points to the last element added and if the stack is empty, an error arises. Also refered as Stack.peek()</p> </li> <li> <p>Stack.isEmpty(): Boolean attribute, indicates if the stack is empty or not. </p> </li> <li> <p>len(Stack): Number of existing elements in the stack. </p> </li> </ul>"},{"location":"Notes/dsa/stack/#applications","title":"Applications","text":"<p>Stacks are used in a wide variety of scenarios, such as the stack that saves our operations made in some program so we can use the undo command (ctrl+z) to return to the last operation made (execute(operation_history.pop())).</p> <p>Another application of stacks is seen in web browsers, which keep a record of recently visited sites wo you can move easily between visited pages.</p> <p>Stacks are also used to verify matching expressions, such as opening-closing pairs of parenthesis, brackets, or even markup tags. Artithmetic expressions can also be verified using stacks through Reverse Polish notation. </p>"},{"location":"Notes/dsa/stack/#code-implementation","title":"Code Implementation","text":"<p>For the main implementation, we used the List data type as base for our Stack class.</p>"},{"location":"Notes/dsa/stack/#python-implementation","title":"Python implementation","text":"Python Binary Search in Python<pre><code>class Stack:\n    def __init__(self):\n    self.items = []\n\n    def is_empty(self):\n        return not self.items #Same as len(self.items) == 0\n\n    def push(self, item):\n        self.items.append(item)\n\n    def pop(self):\n        return self.items.pop()\n\n    def peek(self):\n        return self.items[-1]\n\n    def size(self):\n        return len(self.items)\n\n    def __str__(self):\n        return str(self.items)\n</code></pre>"},{"location":"Notes/dsa/stack/#c-implementation","title":"C++ implementation","text":"<p>In addition to the \"from zero\" implementation, we can also leverage the defined container , defined in STL. </p> <ol> <li> <p>Cormen, T.H. et al. (2022) Introduction to algorithms. Cambridge, MA: The MIT Press.\u00a0\u21a9</p> </li> <li> <p>Goodrich, M.T., Tamassia, R. and Goldwasser, M.H. (2013) Data Structures and algorithms in Python. Hoboken, NJ: Wiley.\u00a0\u21a9</p> </li> <li> <p>Skiena, S.S. (2020) The Algorithm Design Manual. 3rd edn. Springer.\u00a0\u21a9</p> </li> <li> <p>Introduction to algorithms: Electrical Engineering and computer science MIT OpenCourseWare. Available at: https://ocw.mit.edu/courses/6-006-introduction-to-algorithms-spring-2020/ (Accessed: 29 September 2024).\u00a0\u21a9</p> </li> <li> <p>Data Structures &amp; Algorithms - Linked Lists - Singly Linked Lists. Available at: https://youtu.be/gpvtfbwgUxM?list=PLaBPUIXZ8s4D2onKZ2wj7dUCglYfA5wBd\u00a0\u21a9</p> </li> </ol>"},{"location":"Notes/python/python/","title":"Python general notes","text":""},{"location":"blog/","title":"Blog","text":""}]}